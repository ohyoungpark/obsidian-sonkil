/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
https://github.com/ohyoungpark/obsidian-sonkil
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SonkilPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/RecenterCursorPlugin.ts
var import_view = require("@codemirror/view");
var RecenterCursorPlugin = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.modes = ["center", "start", "end"];
    this.currentIndex = 0;
    this.registerCommands();
  }
  registerCommands() {
    this.plugin.addCommand({
      id: "sonkil-recenter-editor",
      name: "Recenter editor",
      hotkeys: [{ modifiers: ["Ctrl"], key: "l" }],
      editorCallback: (editor) => {
        this.recenterEditor(editor);
      }
    });
  }
  getNextMode() {
    const mode = this.modes[this.currentIndex];
    this.currentIndex = (this.currentIndex + 1) % this.modes.length;
    return mode;
  }
  reset() {
    if (this.currentIndex !== 0) {
      this.currentIndex = 0;
    }
  }
  recenterEditor(editor) {
    const cmView = editor.cm;
    if (!cmView)
      return;
    const pos = cmView.state.selection.main.head;
    const line = cmView.state.doc.lineAt(pos);
    const mode = this.getNextMode();
    cmView.dispatch({
      effects: import_view.EditorView.scrollIntoView(line.from, {
        y: mode,
        x: "nearest"
      })
    });
  }
};

// src/KillRing.ts
var KILL_RING_MAX_SIZE = 120;
var KillRing = class {
  constructor(clipboard = navigator.clipboard) {
    this.items = [];
    this.currentIndex = -1;
    this.clipboard = clipboard;
  }
  add(text) {
    this.items.push(text);
    if (this.items.length > KILL_RING_MAX_SIZE) {
      this.items = this.items.slice(-KILL_RING_MAX_SIZE);
    }
    this.currentIndex = this.items.length - 1;
    this.clipboard.writeText(text).catch((err) => {
      console.error("Failed to write to clipboard:", err);
    });
  }
  decreaseCurrentIndex() {
    if (this.items.length === 0)
      return;
    this.currentIndex = (this.currentIndex - 1 + this.items.length) % this.items.length;
  }
  getCurrentItem() {
    if (this.currentIndex === -1 || this.items.length === 0)
      return null;
    return this.items[this.currentIndex];
  }
};

// src/KillAndYankPlugin.ts
var KillAndYankPlugin = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.positions = {
      mark: null,
      yank: null
    };
    this.killRing = new KillRing();
    this.registerCommands();
  }
  registerCommands() {
    this.plugin.addCommand({
      id: "sonkil-set-mark",
      name: "Set mark",
      hotkeys: [{ modifiers: ["Ctrl"], key: " " }],
      editorCallback: (editor) => {
        this.setMark(editor);
      }
    });
    this.plugin.addCommand({
      id: "sonkil-kill-line",
      name: "Kill line",
      hotkeys: [{ modifiers: ["Ctrl"], key: "k" }],
      editorCallback: (editor) => {
        this.killLine(editor);
      }
    });
    this.plugin.addCommand({
      id: "sonkil-kill-region",
      name: "Kill region",
      hotkeys: [{ modifiers: ["Ctrl"], key: "w" }],
      editorCallback: (editor) => {
        this.killRegion(editor);
      }
    });
    this.plugin.addCommand({
      id: "sonkil-copy-region",
      name: "Copy region",
      hotkeys: [{ modifiers: ["Alt"], key: "w" }],
      editorCallback: (editor) => {
        this.copyRegion(editor);
      }
    });
    this.plugin.addCommand({
      id: "sonkil-yank",
      name: "Yank",
      hotkeys: [{ modifiers: ["Ctrl"], key: "y" }],
      editorCallback: (editor) => {
        this.reset();
        this.yank(editor);
      }
    });
    this.plugin.addCommand({
      id: "sonkil-yank-pop",
      name: "Yank pop",
      hotkeys: [{ modifiers: ["Alt"], key: "y" }],
      editorCallback: (editor) => {
        this.yank(editor);
      }
    });
  }
  sortPositions(a, b) {
    return a.line < b.line || a.line === b.line && a.ch <= b.ch ? [a, b] : [b, a];
  }
  killLine(editor) {
    const cursorPosition = editor.getCursor();
    const line = editor.getLine(cursorPosition.line);
    const text = line.slice(cursorPosition.ch);
    if (text.trim() === "") {
      const nextLineFirstCharPosition = { line: cursorPosition.line + 1, ch: 0 };
      editor.replaceRange("", cursorPosition, nextLineFirstCharPosition);
      return;
    }
    this.killRing.add(text);
    const lastCharPosition = { line: cursorPosition.line, ch: line.length };
    editor.replaceRange("", cursorPosition, lastCharPosition);
  }
  killRegion(editor) {
    if (this.positions.mark) {
      const from = this.positions.mark;
      const to = editor.getCursor();
      const [start, end] = this.sortPositions(from, to);
      const text = editor.getRange(start, end);
      this.killRing.add(text);
      editor.replaceRange("", start, end);
      this.positions.mark = null;
    } else {
      const selection = editor.getSelection();
      if (selection) {
        this.killRing.add(selection);
        editor.replaceSelection("");
      }
    }
  }
  copyRegion(editor) {
    if (this.positions.mark) {
      const from = this.positions.mark;
      const to = editor.getCursor();
      const [start, end] = this.sortPositions(from, to);
      const text = editor.getRange(start, end);
      this.killRing.add(text);
      this.positions.mark = null;
    } else {
      const selection = editor.getSelection();
      if (selection) {
        this.killRing.add(selection);
      }
    }
  }
  async yank(editor) {
    if (this.killRing.getCurrentItem() === null) {
      const clipboardText = await navigator.clipboard.readText();
      if (clipboardText) {
        this.killRing.add(clipboardText);
      }
    }
    const cursorPosition = editor.getCursor();
    if (!this.positions.yank) {
      this.positions.yank = cursorPosition;
    } else {
      this.killRing.decreaseCurrentIndex();
    }
    const currentItem = this.killRing.getCurrentItem();
    if (currentItem) {
      editor.setSelection(this.positions.yank, cursorPosition);
      editor.replaceSelection(currentItem);
    }
  }
  setMark(editor) {
    const cursorPosition = editor.getCursor();
    this.positions.mark = cursorPosition;
  }
  reset() {
    this.positions.yank = null;
    this.positions.mark = null;
  }
};

// src/MultiCursorPlugin.ts
var MultiCursorPlugin = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.mainPosition = null;
    this.registerCommands();
  }
  registerCommands() {
    this.plugin.addCommand({
      id: "sonkil-add-cursor-up",
      name: "Add cursor up",
      hotkeys: [{ modifiers: ["Ctrl", "Shift"], key: "ArrowUp" }],
      editorCallback: (editor) => {
        this.addCursor(editor, "up");
      }
    });
    this.plugin.addCommand({
      id: "sonkil-add-cursor-down",
      name: "Add cursor down",
      hotkeys: [{ modifiers: ["Ctrl", "Shift"], key: "ArrowDown" }],
      editorCallback: (editor) => {
        this.addCursor(editor, "down");
      }
    });
  }
  addCursor(editor, direction) {
    const cursors = editor.listSelections();
    let currentLine;
    if (direction === "up") {
      currentLine = cursors[0].anchor.line - 1;
    } else {
      currentLine = cursors[cursors.length - 1].anchor.line + 1;
    }
    if (currentLine < 0 || currentLine >= editor.lineCount()) {
      return;
    }
    if (!this.mainPosition) {
      this.mainPosition = editor.getCursor();
    }
    const newCursor = {
      line: currentLine,
      ch: Math.min(
        this.mainPosition.ch,
        editor.getLine(currentLine).length
      )
    };
    cursors.push({ anchor: newCursor, head: newCursor });
    editor.setSelections(cursors);
  }
  reset(editor) {
    if (this.mainPosition) {
      editor.setCursor(this.mainPosition);
      this.mainPosition = null;
    }
  }
};

// src/SwapPlugin.ts
var SwapPlugin = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.registerCommands();
  }
  registerCommands() {
    this.plugin.addCommand({
      id: "sonkil-move-line-up",
      name: "Move line up",
      hotkeys: [{ modifiers: ["Ctrl", "Meta"], key: "ArrowUp" }],
      editorCallback: (editor) => {
        this.moveLineUp(editor);
      }
    });
    this.plugin.addCommand({
      id: "sonkil-move-line-down",
      name: "Move line down",
      hotkeys: [{ modifiers: ["Ctrl", "Meta"], key: "ArrowDown" }],
      editorCallback: (editor) => {
        this.moveLineDown(editor);
      }
    });
  }
  moveLineUp(editor) {
    editor.exec("swapLineUp");
  }
  moveLineDown(editor) {
    editor.exec("swapLineDown");
  }
};

// src/KeyController.ts
var import_obsidian = require("obsidian");
var KeyController = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.keyBindings = [];
    this.KeyToCodeMap = {
      " ": "Space",
      "g": "KeyG",
      "k": "KeyK",
      "w": "KeyW",
      "y": "KeyY",
      "l": "KeyL",
      "ArrowUp": "ArrowUp",
      "ArrowDown": "ArrowDown"
    };
    this.initializeKeyBindings();
  }
  initializeKeyBindings() {
    const commands = this.plugin.app.commands.commands;
    const pluginId = this.plugin.manifest.id;
    Object.entries(commands).filter(([id]) => id.startsWith(`${pluginId}:sonkil-`)).forEach(([id, command]) => {
      if (command.hotkeys && command.hotkeys.length > 0) {
        command.hotkeys.forEach((hotkey) => {
          this.keyBindings.push({
            key: hotkey.key,
            modifiers: {
              ctrlKey: hotkey.modifiers.includes("Ctrl"),
              altKey: hotkey.modifiers.includes("Alt"),
              shiftKey: hotkey.modifiers.includes("Shift"),
              metaKey: hotkey.modifiers.includes("Meta")
            },
            commandId: id,
            description: command.name
          });
        });
      }
    });
  }
  handleKeyEvent(evt) {
    const view = this.plugin.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!view)
      return false;
    const target = evt.target;
    if (target.classList.contains("inline-title") || target.closest(".inline-title") !== null) {
      return false;
    }
    if (evt.ctrlKey || evt.altKey || evt.key === "Escape") {
      for (const binding of this.keyBindings) {
        if (this.isKeyBindingMatch(evt, binding)) {
          this.plugin.app.commands.executeCommandById(binding.commandId);
          return true;
        }
      }
    }
    if (!["Control", "Alt"].includes(evt.key)) {
      this.plugin.app.commands.executeCommandById("sonkil-mode-quit");
    }
    return false;
  }
  isKeyBindingMatch(evt, binding) {
    const keyPressed = evt.key.toLowerCase();
    const codePressed = evt.code;
    const bindingKey = binding.key.toLowerCase();
    const keyMatches = codePressed === this.KeyToCodeMap[bindingKey] || keyPressed === bindingKey;
    return keyMatches && evt.ctrlKey === binding.modifiers.ctrlKey && evt.altKey === binding.modifiers.altKey && evt.shiftKey === binding.modifiers.shiftKey && evt.metaKey === binding.modifiers.metaKey;
  }
};

// src/main.ts
var SonkilPlugin = class extends import_obsidian2.Plugin {
  async onload() {
    console.log("Sonkil plugin loaded, kill ring initialized");
    this.recenterPlugin = new RecenterCursorPlugin(this);
    this.killAndYankPlugin = new KillAndYankPlugin(this);
    this.multiCursorPlugin = new MultiCursorPlugin(this);
    this.swapPlugin = new SwapPlugin(this);
    this.addCommand({
      id: "sonkil-mode-quit",
      name: "Cancel mark and exit yank mode",
      hotkeys: [{ modifiers: ["Ctrl"], key: "g" }],
      editorCallback: (editor) => {
        this.modeQuit(editor);
      }
    });
    this.keyController = new KeyController(this);
    this.registerDomEvent(
      document,
      "keydown",
      (evt) => {
        const shouldBlockEvent = this.keyController.handleKeyEvent(evt);
        if (shouldBlockEvent) {
          evt.preventDefault();
          evt.stopPropagation();
        }
      },
      true
    );
    this.registerDomEvent(document, "mousedown", () => {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
      if (view) {
        const editor = view.editor;
        setTimeout(() => {
          this.modeQuit(editor);
        }, 10);
      }
    });
  }
  modeQuit(editor) {
    this.killAndYankPlugin.reset();
    this.recenterPlugin.reset();
    this.multiCursorPlugin.reset(editor);
  }
};
