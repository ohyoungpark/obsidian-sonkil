/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
https://github.com/ohyoungpark/obsidian-sonkil
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SonkilPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/RecenterCursorPlugin.ts
var import_view = require("@codemirror/view");
var RecenterCursorPlugin = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.modes = ["center", "start", "end"];
    this.currentIndex = 0;
    this.registerCommands();
  }
  registerCommands() {
    this.plugin.addCommand({
      id: "sonkil-recenter-editor",
      name: "Recenter editor",
      hotkeys: [{ modifiers: ["Ctrl"], key: "l" }],
      editorCallback: (editor) => {
        this.recenterEditor(editor);
      }
    });
  }
  getNextMode() {
    const mode = this.modes[this.currentIndex];
    this.currentIndex = (this.currentIndex + 1) % this.modes.length;
    return mode;
  }
  reset() {
    if (this.currentIndex !== 0) {
      this.currentIndex = 0;
    }
  }
  recenterEditor(editor) {
    const cmView = editor.cm;
    if (!cmView)
      return;
    const pos = cmView.state.selection.main.head;
    const line = cmView.state.doc.lineAt(pos);
    const mode = this.getNextMode();
    cmView.dispatch({
      effects: import_view.EditorView.scrollIntoView(line.from, {
        y: mode,
        x: "nearest"
      })
    });
  }
};

// src/KillRing.ts
var KILL_RING_MAX_SIZE = 120;
var KillRing = class {
  constructor(clipboard = navigator.clipboard) {
    this.items = [];
    this.currentIndex = -1;
    this.clipboard = clipboard;
  }
  add(text) {
    this.items.push(text);
    if (this.items.length > KILL_RING_MAX_SIZE) {
      this.items = this.items.slice(-KILL_RING_MAX_SIZE);
    }
    this.currentIndex = this.items.length - 1;
    this.clipboard.writeText(text).catch((err) => {
      console.error("Failed to write to clipboard:", err);
    });
  }
  decreaseCurrentIndex() {
    if (this.items.length === 0)
      return;
    this.currentIndex = (this.currentIndex - 1 + this.items.length) % this.items.length;
  }
  getCurrentItem() {
    if (this.currentIndex === -1 || this.items.length === 0)
      return null;
    return this.items[this.currentIndex];
  }
};

// src/KillAndYankPlugin.ts
var import_state = require("@codemirror/state");
var import_view2 = require("@codemirror/view");
var markSelectionEffect = import_state.StateEffect.define();
var KillAndYankPlugin = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.markPosition = null;
    this.yankPositions = [];
    this.markSelectionField = import_state.StateField.define({
      create() {
        return import_view2.Decoration.none;
      },
      update(value, tr) {
        value = value.map(tr.changes);
        for (const e of tr.effects) {
          if (e.is(markSelectionEffect)) {
            const range = e.value;
            if (range.from === -1 && range.to === -1) {
              value = import_view2.Decoration.none;
            } else {
              value = import_view2.Decoration.set([
                import_view2.Decoration.mark({
                  class: "mark-selection",
                  attributes: { style: "background-color: rgba(0, 120, 215, 0.2);" }
                }).range(range.from, range.to)
              ]);
            }
          }
        }
        return value;
      },
      provide: (f) => import_state.Prec.highest(import_view2.EditorView.decorations.from(f))
    });
    this.killRing = new KillRing();
    this.registerCommands();
  }
  registerCommands() {
    this.plugin.addCommand({
      id: "sonkil-set-mark",
      name: "Set mark",
      hotkeys: [{ modifiers: ["Ctrl"], key: " " }],
      editorCallback: (editor) => {
        this.setMark(editor);
      }
    });
    this.plugin.addCommand({
      id: "sonkil-kill-line",
      name: "Kill line",
      hotkeys: [{ modifiers: ["Ctrl"], key: "k" }],
      editorCallback: (editor) => {
        this.killLines(editor);
      }
    });
    this.plugin.addCommand({
      id: "sonkil-kill-region",
      name: "Kill region",
      hotkeys: [{ modifiers: ["Ctrl"], key: "w" }],
      editorCallback: (editor) => {
        this.killRegion(editor);
      }
    });
    this.plugin.addCommand({
      id: "sonkil-copy-region",
      name: "Copy region",
      hotkeys: [{ modifiers: ["Alt"], key: "w" }],
      editorCallback: (editor) => {
        this.copyRegion(editor);
      }
    });
    this.plugin.addCommand({
      id: "sonkil-yank",
      name: "Yank",
      hotkeys: [{ modifiers: ["Ctrl"], key: "y" }],
      editorCallback: (editor) => {
        this.yank(editor);
      }
    });
    this.plugin.addCommand({
      id: "sonkil-yank-pop",
      name: "Yank pop",
      hotkeys: [{ modifiers: ["Alt"], key: "y" }],
      editorCallback: (editor) => {
        this.yankPop(editor);
      }
    });
  }
  sortPositions(a, b) {
    return a.line < b.line || a.line === b.line && a.ch <= b.ch ? [a, b] : [b, a];
  }
  sortNumbers(a, b) {
    return a <= b ? [a, b] : [b, a];
  }
  killLines(editor) {
    const selections = editor.listSelections();
    const killedTexts = [];
    selections.forEach((selection) => {
      const line = editor.getLine(selection.head.line);
      const text = line.slice(selection.head.ch);
      killedTexts.push(text);
      const lastCharPosition = { line: selection.head.line, ch: line.length };
      editor.replaceRange("", selection.head, lastCharPosition);
    });
    const combinedText = killedTexts.join("\n");
    if (combinedText.trim() === "") {
      const firstLine = selections[0].head.line;
      const lastLine = selections[selections.length - 1].head.line;
      const firstCharPosition = { line: firstLine, ch: selections[0].head.ch };
      const lastCharPosition = { line: lastLine + 1, ch: 0 };
      editor.replaceRange("", firstCharPosition, lastCharPosition);
      return;
    }
    this.killRing.add(combinedText);
  }
  killRegion(editor) {
    if (this.markPosition) {
      const from = this.markPosition;
      const to = editor.getCursor();
      const [start, end] = this.sortPositions(from, to);
      const text = editor.getRange(start, end);
      this.killRing.add(text);
      editor.replaceRange("", start, end);
      this.resetMarkSelection(editor);
    } else {
      const selection = editor.getSelection();
      if (selection) {
        this.killRing.add(selection);
        editor.replaceSelection("");
      }
    }
  }
  copyRegion(editor) {
    if (this.markPosition) {
      const from = this.markPosition;
      const to = editor.getCursor();
      const [start, end] = this.sortPositions(from, to);
      const text = editor.getRange(start, end);
      this.killRing.add(text);
      this.resetMarkSelection(editor);
    } else {
      const selection = editor.getSelection();
      if (selection) {
        this.killRing.add(selection);
      }
    }
  }
  async yank(editor) {
    this.resetYank();
    await this.yankPop(editor);
  }
  async yankPop(editor) {
    if (this.killRing.getCurrentItem() === null) {
      const clipboardText = await navigator.clipboard.readText();
      if (clipboardText) {
        this.killRing.add(clipboardText);
      }
    }
    const selections = editor.listSelections();
    const cursorPositions = selections.map((selection) => selection.head);
    if (!this.yankPositions.length) {
      this.yankPositions = cursorPositions;
    } else {
      this.killRing.decreaseCurrentIndex();
    }
    const currentItem = this.killRing.getCurrentItem();
    if (currentItem) {
      const selections2 = cursorPositions.map((cursorPos, i) => ({
        anchor: this.yankPositions[i],
        head: cursorPos
      }));
      editor.setSelections(selections2);
      editor.replaceSelection(currentItem);
    }
  }
  setMark(editor) {
    const cursorPosition = editor.getCursor();
    this.markPosition = cursorPosition;
  }
  reset(editor) {
    this.resetYank();
    this.resetMarkSelection(editor);
  }
  resetYank() {
    this.yankPositions = [];
  }
  updateMarkSelection(editor, pos) {
    if (!this.markPosition) {
      return;
    }
    const cm = editor.cm;
    if (!cm)
      return;
    const start = editor.posToOffset(this.markPosition);
    const end = pos;
    const [from, to] = this.sortNumbers(start, end);
    if (from === to) {
      return;
    }
    cm.dispatch({
      effects: markSelectionEffect.of({ from, to })
    });
  }
  resetMarkSelection(editor) {
    if (!this.markPosition)
      return;
    const cm = editor.cm;
    if (!cm)
      return;
    this.markPosition = null;
    cm.dispatch({
      effects: markSelectionEffect.of({ from: -1, to: -1 })
    });
  }
};

// src/MultiCursorPlugin.ts
var MultiCursorPlugin = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.mainPosition = null;
    this.registerCommands();
  }
  registerCommands() {
    this.plugin.addCommand({
      id: "sonkil-add-cursor-up",
      name: "Add cursor up",
      hotkeys: [{ modifiers: ["Ctrl", "Shift"], key: "ArrowUp" }],
      editorCallback: (editor) => {
        this.addCursor(editor, "up");
      }
    });
    this.plugin.addCommand({
      id: "sonkil-add-cursor-down",
      name: "Add cursor down",
      hotkeys: [{ modifiers: ["Ctrl", "Shift"], key: "ArrowDown" }],
      editorCallback: (editor) => {
        this.addCursor(editor, "down");
      }
    });
  }
  addCursor(editor, direction) {
    const cursors = editor.listSelections();
    let currentLine;
    if (direction === "up") {
      currentLine = cursors[0].anchor.line - 1;
    } else {
      currentLine = cursors[cursors.length - 1].anchor.line + 1;
    }
    if (currentLine < 0 || currentLine >= editor.lineCount()) {
      return;
    }
    if (!this.mainPosition) {
      this.mainPosition = editor.getCursor();
    }
    const newCursor = {
      line: currentLine,
      ch: Math.min(this.mainPosition.ch, editor.getLine(currentLine).length)
    };
    cursors.push({ anchor: newCursor, head: newCursor });
    editor.setSelections(cursors);
  }
  reset(editor) {
    const selections = editor.listSelections();
    if (selections.length > 1) {
      if (this.mainPosition) {
        editor.setCursor(this.mainPosition);
      } else {
        editor.setCursor(selections[0].anchor);
      }
    }
    this.mainPosition = null;
  }
};

// src/SwapPlugin.ts
var SwapPlugin = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.registerCommands();
  }
  registerCommands() {
    this.plugin.addCommand({
      id: "sonkil-move-line-up",
      name: "Move line up",
      hotkeys: [{ modifiers: ["Ctrl", "Alt"], key: "ArrowUp" }],
      editorCallback: (editor) => {
        this.moveLineUp(editor);
      }
    });
    this.plugin.addCommand({
      id: "sonkil-move-line-down",
      name: "Move line down",
      hotkeys: [{ modifiers: ["Ctrl", "Alt"], key: "ArrowDown" }],
      editorCallback: (editor) => {
        this.moveLineDown(editor);
      }
    });
  }
  moveLineUp(editor) {
    editor.exec("swapLineUp");
  }
  moveLineDown(editor) {
    editor.exec("swapLineDown");
  }
};

// src/KeyController.ts
var import_obsidian = require("obsidian");
var KeyController = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.keyBindings = [];
    this.KeyToCodeMap = {
      " ": "Space",
      g: "KeyG",
      k: "KeyK",
      w: "KeyW",
      y: "KeyY",
      l: "KeyL",
      ArrowUp: "ArrowUp",
      ArrowDown: "ArrowDown"
    };
    this.initializeKeyBindings();
  }
  initializeKeyBindings() {
    const commands = this.plugin.app.commands.commands;
    const pluginId = this.plugin.manifest.id;
    Object.entries(commands).filter(([id]) => id.startsWith(`${pluginId}:sonkil-`)).forEach(([id, command]) => {
      if (command.hotkeys && command.hotkeys.length > 0) {
        command.hotkeys.forEach((hotkey) => {
          this.keyBindings.push({
            key: hotkey.key,
            modifiers: {
              ctrlKey: hotkey.modifiers.includes("Ctrl"),
              altKey: hotkey.modifiers.includes("Alt"),
              shiftKey: hotkey.modifiers.includes("Shift"),
              metaKey: hotkey.modifiers.includes("Meta")
            },
            commandId: id,
            description: command.name
          });
        });
      }
    });
  }
  handleKeyEvent(evt) {
    const view = this.plugin.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!view)
      return false;
    const target = evt.target;
    if (target.classList.contains("inline-title") || target.closest(".inline-title") !== null) {
      return false;
    }
    if (evt.ctrlKey || evt.altKey || evt.key === "Escape") {
      for (const binding of this.keyBindings) {
        if (this.isKeyBindingMatch(evt, binding)) {
          this.plugin.app.commands.executeCommandById(
            binding.commandId
          );
          return true;
        }
      }
    }
    if (!["Control", "Alt"].includes(evt.key)) {
      return null;
    }
    return false;
  }
  isKeyBindingMatch(evt, binding) {
    const keyPressed = evt.key.toLowerCase();
    const codePressed = evt.code;
    const bindingKey = binding.key.toLowerCase();
    const keyMatches = codePressed === this.KeyToCodeMap[bindingKey] || keyPressed === bindingKey;
    return keyMatches && evt.ctrlKey === binding.modifiers.ctrlKey && evt.altKey === binding.modifiers.altKey && evt.shiftKey === binding.modifiers.shiftKey && evt.metaKey === binding.modifiers.metaKey;
  }
};

// src/main.ts
var import_view3 = require("@codemirror/view");
var import_state2 = require("@codemirror/state");
var SonkilPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.listener = null;
  }
  setupListener(editor) {
    if (!this.listener) {
      const cm = editor.cm;
      this.listener = import_view3.EditorView.updateListener.of((update) => {
        if (update.selectionSet) {
          const from = update.startState.selection.main.head;
          const to = update.state.selection.main.head;
          if (update.docChanged && from !== to) {
            this.killAndYankPlugin.resetMarkSelection(editor);
          }
          this.killAndYankPlugin.updateMarkSelection(editor, to);
        }
      });
      cm.dispatch({
        effects: import_state2.StateEffect.appendConfig.of([
          this.killAndYankPlugin.markSelectionField,
          this.listener
        ])
      });
    }
  }
  handleActiveLeafChange(leaf) {
    if (leaf && leaf instanceof import_obsidian2.MarkdownView) {
      const view = leaf;
      if (view && view.editor) {
        this.setupListener(view.editor);
      }
    }
  }
  async onload() {
    console.log("Sonkil plugin loaded, kill ring initialized");
    this.recenterPlugin = new RecenterCursorPlugin(this);
    this.killAndYankPlugin = new KillAndYankPlugin(this);
    this.multiCursorPlugin = new MultiCursorPlugin(this);
    new SwapPlugin(this);
    this.addCommand({
      id: "sonkil-mode-quit",
      name: "Cancel mark and exit yank mode",
      hotkeys: [{ modifiers: ["Ctrl"], key: "g" }],
      editorCallback: (editor) => {
        this.modeQuit(editor);
      }
    });
    this.keyController = new KeyController(this);
    this.registerDomEvent(
      document,
      "keydown",
      (evt) => {
        const shouldBlockEvent = this.keyController.handleKeyEvent(evt);
        if (shouldBlockEvent === null) {
          this.killAndYankPlugin.resetYank();
        }
        if (shouldBlockEvent) {
          evt.preventDefault();
          evt.stopPropagation();
        }
      },
      true
    );
    this.registerDomEvent(document, "mousedown", () => {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
      if (view) {
        const editor = view.editor;
        setTimeout(() => {
          this.modeQuit(editor);
        }, 10);
      }
    });
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", (leaf) => {
        this.handleActiveLeafChange(leaf);
      })
    );
  }
  modeQuit(editor) {
    this.killAndYankPlugin.reset(editor);
    this.recenterPlugin.reset();
    this.multiCursorPlugin.reset(editor);
  }
};
