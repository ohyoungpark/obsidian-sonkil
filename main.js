/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
https://github.com/ohyoungpark/obsidian-sonkil
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SonkilPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_view = require("@codemirror/view");

// src/killRing.ts
var KillRing = class {
  constructor(maxSize = 60, clipboard = navigator.clipboard) {
    this.items = [];
    this.currentIndex = -1;
    this.maxSize = maxSize;
    this.clipboard = clipboard;
  }
  add(text) {
    this.items.push(text);
    if (this.items.length > this.maxSize) {
      this.items = this.items.slice(-this.maxSize);
    }
    this.currentIndex = this.items.length - 1;
    this.clipboard.writeText(text).catch((err) => {
      console.error("Failed to write to clipboard:", err);
    });
  }
  decreaseCurrentIndex() {
    if (this.items.length === 0)
      return;
    this.currentIndex = (this.currentIndex - 1 + this.items.length) % this.items.length;
  }
  getCurrentItem() {
    if (this.currentIndex === -1 || this.items.length === 0)
      return null;
    return this.items[this.currentIndex];
  }
  setMaxSize(newSize) {
    if (newSize < 1)
      throw new Error("Kill Ring size must be at least 1");
    this.maxSize = newSize;
    if (this.items.length > newSize) {
      this.items = this.items.slice(-newSize);
      this.currentIndex = Math.min(this.currentIndex, this.items.length - 1);
    }
  }
};

// src/RecenterCursorPlugin.ts
var RecenterCursorPlugin = class {
  constructor() {
    this.modes = ["center", "start", "end"];
    this.currentIndex = 0;
  }
  getNextMode() {
    const mode = this.modes[this.currentIndex];
    this.currentIndex = (this.currentIndex + 1) % this.modes.length;
    return mode;
  }
  reset() {
    if (this.currentIndex !== 0) {
      this.currentIndex = 0;
    }
  }
};

// src/main.ts
var DEFAULT_KILL_RING_SIZE = 60;
var KeyToCodeMap = {
  " ": "Space",
  "g": "KeyG",
  "k": "KeyK",
  "w": "KeyW",
  "y": "KeyY",
  "l": "KeyL",
  "ArrowUp": "ArrowUp",
  "ArrowDown": "ArrowDown"
};
var SonkilPlugin = class extends import_obsidian.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    this.recenterPlugin = new RecenterCursorPlugin();
    this.positions = {
      yank: null,
      mark: null,
      main: null
    };
    this.config = {
      killRingMaxSize: DEFAULT_KILL_RING_SIZE
    };
    this.killRing = new KillRing(DEFAULT_KILL_RING_SIZE);
    this.keyBindings = [
      {
        key: "g",
        modifiers: { ctrlKey: true, altKey: false, shiftKey: false, metaKey: false },
        action: (editor) => {
          this.modeQuit(editor);
          return true;
        },
        description: "Cancel mark and exit yank mode"
      },
      {
        key: " ",
        modifiers: { ctrlKey: true, altKey: false, shiftKey: false, metaKey: false },
        action: (editor) => {
          this.positions.mark = editor.getCursor();
          return true;
        },
        description: "Set mark"
      },
      {
        key: "k",
        modifiers: { ctrlKey: true, altKey: false, shiftKey: false, metaKey: false },
        action: (editor) => {
          this.killLine(editor);
          return true;
        },
        description: "Kill line"
      },
      {
        key: "w",
        modifiers: { ctrlKey: true, altKey: false, shiftKey: false, metaKey: false },
        action: (editor) => {
          this.killRegion(editor);
          return true;
        },
        description: "Kill region"
      },
      {
        key: "w",
        modifiers: { ctrlKey: false, altKey: true, shiftKey: false, metaKey: false },
        action: (editor) => {
          this.killRegion(editor, true);
          return true;
        },
        description: "Copy region"
      },
      {
        key: "y",
        modifiers: { ctrlKey: true, altKey: false, shiftKey: false, metaKey: false },
        action: (editor) => {
          this.positions.yank = null;
          this.yank(editor);
          return true;
        },
        description: "Yank"
      },
      {
        key: "y",
        modifiers: { ctrlKey: false, altKey: true, shiftKey: false, metaKey: false },
        action: (editor) => {
          this.yank(editor);
          return true;
        },
        description: "Yank pop"
      },
      {
        key: "l",
        modifiers: { ctrlKey: true, altKey: false, shiftKey: false, metaKey: false },
        action: (editor) => {
          this.recenterEditor(editor);
          return true;
        },
        description: "Recenter editor"
      },
      {
        key: "ArrowUp",
        modifiers: { ctrlKey: true, altKey: false, shiftKey: false, metaKey: true },
        action: (editor) => {
          this.moveLineUp(editor);
          return true;
        },
        description: "Move line up"
      },
      {
        key: "ArrowDown",
        modifiers: { ctrlKey: true, altKey: false, shiftKey: false, metaKey: true },
        action: (editor) => {
          this.moveLineDown(editor);
          return true;
        },
        description: "Move line down"
      },
      {
        key: "ArrowUp",
        modifiers: { ctrlKey: true, altKey: false, shiftKey: true, metaKey: false },
        action: (editor) => {
          this.addCursorUp(editor);
          return true;
        },
        description: "Add cursor up"
      },
      {
        key: "ArrowDown",
        modifiers: { ctrlKey: true, altKey: false, shiftKey: true, metaKey: false },
        action: (editor) => {
          this.addCursorDown(editor);
          return true;
        },
        description: "Add cursor down"
      }
    ];
  }
  async onload() {
    await this.loadConfig();
    console.log("Sonkil plugin loaded, kill ring initialized");
    this.registerDomEvent(
      document,
      "keydown",
      (evt) => {
        const target = evt.target;
        if (target.classList.contains("inline-title") || target.closest(".inline-title") !== null) {
          console.log("Inline title detected, skipping");
          return;
        }
        const shouldBlockEvent = this.handleKeyEvent(evt);
        if (shouldBlockEvent) {
          evt.preventDefault();
          evt.stopPropagation();
        }
      },
      true
    );
    this.registerDomEvent(document, "mousedown", () => {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (view) {
        const editor = view.editor;
        setTimeout(() => {
          this.modeQuit(editor);
        }, 10);
      }
    });
    this.keyBindings.forEach((binding) => {
      const commandId = `sonkil-${binding.description.toLowerCase().replace(/\s+/g, "-")}`;
      const commandName = binding.description;
      this.addCommand({
        id: commandId,
        name: commandName,
        hotkeys: this.keybindingToHotkeys(binding),
        editorCallback: (editor) => {
          binding.action(editor);
        }
      });
    });
    this.addSettingTab(new SonkilSettingTab(this.app, this));
  }
  keybindingToHotkeys(keybinding) {
    const modifiers = [];
    if (keybinding.modifiers.ctrlKey)
      modifiers.push("Mod");
    if (keybinding.modifiers.altKey)
      modifiers.push("Alt");
    if (keybinding.modifiers.shiftKey)
      modifiers.push("Shift");
    if (keybinding.modifiers.metaKey)
      modifiers.push("Meta");
    return [{
      modifiers,
      key: keybinding.key
    }];
  }
  sortPositions(a, b) {
    return a.line < b.line || a.line === b.line && a.ch <= b.ch ? [a, b] : [b, a];
  }
  killLine(editor) {
    const cursorPosition = editor.getCursor();
    const line = editor.getLine(cursorPosition.line);
    const text = line.slice(cursorPosition.ch);
    if (text.trim() === "") {
      const nextLineFirstCharPosition = { line: cursorPosition.line + 1, ch: 0 };
      editor.replaceRange("", cursorPosition, nextLineFirstCharPosition);
      return;
    }
    this.killRing.add(text);
    const lastCharPosition = { line: cursorPosition.line, ch: line.length };
    editor.replaceRange("", cursorPosition, lastCharPosition);
  }
  killRegion(editor, copyOnly = false) {
    if (this.positions.mark) {
      const from = this.positions.mark;
      const to = editor.getCursor();
      const [start, end] = this.sortPositions(from, to);
      const text = editor.getRange(start, end);
      this.killRing.add(text);
      if (!copyOnly) {
        editor.replaceRange("", start, end);
      }
      this.positions.mark = null;
    } else {
      const selection = editor.getSelection();
      if (selection) {
        this.killRing.add(selection);
        if (!copyOnly) {
          editor.replaceSelection("");
        }
      }
    }
  }
  async yank(editor) {
    if (this.killRing.getCurrentItem() === null) {
      const clipboardText = await navigator.clipboard.readText();
      if (clipboardText) {
        this.killRing.add(clipboardText);
      }
    }
    const cursorPostion = editor.getCursor();
    if (!this.positions.yank) {
      this.positions.yank = cursorPostion;
    } else {
      this.killRing.decreaseCurrentIndex();
    }
    const currentItem = this.killRing.getCurrentItem();
    if (currentItem) {
      editor.setSelection(this.positions.yank, cursorPostion);
      editor.replaceSelection(currentItem);
    }
  }
  modeQuit(editor) {
    this.positions.mark = null;
    this.positions.yank = null;
    this.recenterPlugin.reset();
    this.resetMultiCursors(editor);
  }
  handleKeyEvent(evt) {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!view)
      return false;
    const editor = view.editor;
    if (evt.ctrlKey || evt.altKey || evt.key === "Escape") {
      for (const binding of this.keyBindings) {
        if (this.isKeyBindingMatch(evt, binding)) {
          return binding.action(editor);
        }
      }
    }
    if (!["Control", "Alt"].includes(evt.key)) {
      if (this.positions.yank) {
        this.positions.yank = null;
      }
      this.recenterPlugin.reset();
    }
    return false;
  }
  isKeyBindingMatch(evt, binding) {
    const keyPressed = evt.key.toLowerCase();
    const codePressed = evt.code;
    const bindingKey = binding.key.toLowerCase();
    const keyMatches = codePressed === KeyToCodeMap[bindingKey] || keyPressed === bindingKey;
    const modifiersMatch = Object.entries(binding.modifiers).every(([key, value]) => {
      if (value === void 0)
        return true;
      return value === evt[key];
    });
    return keyMatches && modifiersMatch;
  }
  onunload() {
    this.positions.mark = null;
    this.positions.yank = null;
    this.recenterPlugin.reset();
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (view) {
      this.resetMultiCursors(view.editor);
    }
  }
  async loadConfig() {
    const loadedData = await this.loadData();
    if (loadedData) {
      this.config.killRingMaxSize = loadedData.killRingMaxSize || DEFAULT_KILL_RING_SIZE;
    }
    this.killRing = new KillRing(this.config.killRingMaxSize);
  }
  async saveConfig() {
    await this.saveData(this.config);
  }
  async setKillRingMaxSize(size) {
    this.config.killRingMaxSize = size;
    this.killRing.setMaxSize(size);
    await this.saveConfig();
  }
  getKillRingMaxSize() {
    return this.config.killRingMaxSize;
  }
  recenterEditor(editor) {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!view)
      return;
    const cmView = editor.cm;
    if (!cmView)
      return;
    const pos = cmView.state.selection.main.head;
    const line = cmView.state.doc.lineAt(pos);
    const mode = this.recenterPlugin.getNextMode();
    cmView.dispatch({
      effects: import_view.EditorView.scrollIntoView(line.from, {
        y: mode,
        x: "nearest"
      })
    });
  }
  moveLineUp(editor) {
    editor.exec("swapLineUp");
  }
  moveLineDown(editor) {
    editor.exec("swapLineDown");
  }
  addCursorUp(editor) {
    this.addCursor(editor, "up");
  }
  addCursorDown(editor) {
    this.addCursor(editor, "down");
  }
  addCursor(editor, direction) {
    const cursors = editor.listSelections();
    let currentLine;
    if (direction === "up") {
      currentLine = cursors[0].anchor.line - 1;
    } else {
      currentLine = cursors[cursors.length - 1].anchor.line + 1;
    }
    if (currentLine < 0) {
      return;
    } else if (currentLine >= editor.lineCount()) {
      return;
    }
    if (!this.positions.main) {
      this.positions.main = editor.getCursor();
    }
    const newCursor = {
      line: currentLine,
      ch: Math.min(
        this.positions.main.ch,
        editor.getLine(currentLine).length
      )
    };
    cursors.push({ anchor: newCursor, head: newCursor });
    editor.setSelections(cursors);
  }
  resetMultiCursors(editor) {
    if (this.positions.main) {
      editor.setCursor(this.positions.main);
      this.positions.main = null;
    }
  }
};
var SonkilSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.configHandler = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Sonkil Settings" });
    new import_obsidian.Setting(containerEl).setName("Kill Ring Max Size").setDesc("Maximum number of items to keep in the kill ring").addText(
      (text) => text.setPlaceholder("Enter max size").setValue(this.configHandler.getKillRingMaxSize().toString()).onChange(async (value) => {
        const newSize = parseInt(value);
        if (!isNaN(newSize) && newSize > 0) {
          await this.configHandler.setKillRingMaxSize(newSize);
        }
      })
    );
  }
};
