/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
https://github.com/ohyoungpark/obsidian-sonkil
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SonkilPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var SonkilPlugin = class extends import_obsidian.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    this.settings = {
      killRing: [],
      killRingIndex: -1,
      yankPosition: null,
      markPosition: null,
      killRingMaxSize: 60
    };
    this.keyBindings = [
      {
        key: "g",
        code: "KeyG",
        modifiers: { ctrlKey: true, altKey: false, shiftKey: false, metaKey: false },
        action: () => this.keyboardQuit(),
        description: "Cancel mark and exit yank mode",
        isCommand: false
      },
      {
        key: " ",
        code: "Space",
        modifiers: { ctrlKey: true, altKey: false, shiftKey: false, metaKey: false },
        action: (editor) => {
          this.settings.markPosition = editor.getCursor();
          return true;
        },
        description: "Set mark",
        isCommand: true
      },
      {
        key: "k",
        code: "KeyK",
        modifiers: { ctrlKey: true, altKey: false, shiftKey: false, metaKey: false },
        action: (editor) => {
          this.killLine(editor);
          return true;
        },
        description: "Kill line",
        isCommand: true
      },
      {
        key: "w",
        code: "KeyW",
        modifiers: { ctrlKey: true, altKey: false, shiftKey: false, metaKey: false },
        action: (editor) => {
          this.killRegion(editor);
          return true;
        },
        description: "Kill region",
        isCommand: true
      },
      {
        key: "y",
        code: "KeyY",
        modifiers: { ctrlKey: true, altKey: false, shiftKey: false, metaKey: false },
        action: (editor) => {
          this.settings.yankPosition = null;
          this.yank(editor);
          return true;
        },
        description: "Yank",
        isCommand: true
      },
      {
        key: "y",
        code: "KeyY",
        modifiers: { ctrlKey: false, altKey: true, shiftKey: false, metaKey: false },
        action: (editor) => {
          this.yank(editor);
          return true;
        },
        description: "Yank pop",
        isCommand: true
      }
    ];
  }
  async onload() {
    await this.loadSettings();
    console.log("Sonkil plugin loaded, kill ring initialized");
    this.registerDomEvent(document, "keydown", (evt) => {
      const target = evt.target;
      if (target.classList.contains("inline-title") || target.closest(".inline-title") !== null) {
        console.log("Inline title detected, skipping");
        return;
      }
      const isHandled = this.handleKeyEvent(evt);
      if (isHandled) {
        evt.preventDefault();
        evt.stopPropagation();
      }
    }, true);
    this.keyBindings.forEach((binding) => {
      const commandId = `sonkil-${binding.description.toLowerCase().replace(/\s+/g, "-")}`;
      const commandName = `${binding.description} (${binding.modifiers.ctrlKey ? "C-" : ""}${binding.modifiers.altKey ? "M-" : ""}${binding.key})`;
      if (binding.isCommand) {
        this.addCommand({
          id: commandId,
          name: commandName,
          editorCallback: (editor) => {
            binding.action(editor);
          }
        });
      }
    });
    this.addSettingTab(new SonkilSettingTab(this.app, this));
  }
  addToKillRing(text) {
    this.settings.killRing.push(text);
    if (this.settings.killRing.length > this.settings.killRingMaxSize) {
      this.settings.killRing = this.settings.killRing.slice(-this.settings.killRingMaxSize);
    }
    this.settings.killRingIndex = this.settings.killRing.length - 1;
  }
  sortPositions(a, b) {
    return a.line < b.line || a.line === b.line && a.ch <= b.ch ? [a, b] : [b, a];
  }
  killLine(editor) {
    const cursorPosition = editor.getCursor();
    const line = editor.getLine(cursorPosition.line);
    const text = line.slice(cursorPosition.ch);
    if (text.trim() === "") {
      const nextLineFirstCharPosition = { line: cursorPosition.line + 1, ch: 0 };
      editor.replaceRange("", cursorPosition, nextLineFirstCharPosition);
      return;
    }
    this.addToKillRing(text);
    const lastCharPosition = { line: cursorPosition.line, ch: line.length };
    editor.replaceRange("", cursorPosition, lastCharPosition);
  }
  killRegion(editor) {
    if (this.settings.markPosition) {
      const from = this.settings.markPosition;
      const to = editor.getCursor();
      const [start, end] = this.sortPositions(from, to);
      const text = editor.getRange(start, end);
      this.addToKillRing(text);
      editor.replaceRange("", start, end);
      this.settings.markPosition = null;
    } else {
      const selection = editor.getSelection();
      if (selection) {
        this.addToKillRing(selection);
        editor.replaceSelection("");
      }
    }
  }
  getNextKillRingIndex() {
    const index = this.settings.killRingIndex - 1;
    const length = this.settings.killRing.length;
    return (index + length) % length;
  }
  async yank(editor) {
    if (this.settings.killRing.length === 0) {
      const clipboardText = await navigator.clipboard.readText();
      if (clipboardText) {
        this.addToKillRing(clipboardText);
      }
    }
    const cursorPostion = editor.getCursor();
    if (!this.settings.yankPosition) {
      this.settings.yankPosition = cursorPostion;
    } else {
      this.settings.killRingIndex = this.getNextKillRingIndex();
    }
    editor.setSelection(this.settings.yankPosition, cursorPostion);
    editor.replaceSelection(this.settings.killRing[this.settings.killRingIndex]);
  }
  keyboardQuit() {
    this.settings.markPosition = null;
    this.settings.yankPosition = null;
    return true;
  }
  handleKeyEvent(evt) {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!view)
      return false;
    const editor = view.editor;
    if (evt.ctrlKey || evt.altKey) {
      for (const binding of this.keyBindings) {
        if (this.isKeyBindingMatch(evt, binding)) {
          return binding.action(editor);
        }
      }
    }
    if (this.settings.yankPosition && !["Control", "Alt"].includes(evt.key)) {
      this.settings.yankPosition = null;
    }
    return false;
  }
  isKeyBindingMatch(evt, binding) {
    const keyPressed = evt.key.toLowerCase();
    const codePressed = evt.code;
    const keyMatches = codePressed === binding.code || keyPressed === binding.key.toLowerCase();
    const modifiersMatch = Object.entries(binding.modifiers).every(([key, value]) => {
      if (value === void 0)
        return true;
      return value === evt[key];
    });
    return keyMatches && modifiersMatch;
  }
  onunload() {
    console.log("Sonkil plugin unloading, cleaning up kill ring");
    this.settings.killRing = [];
    this.settings.killRingIndex = -1;
    this.settings.yankPosition = null;
    this.settings.markPosition = null;
  }
  async loadSettings() {
    const loadedData = await this.loadData();
    this.settings = {
      killRing: [],
      killRingIndex: -1,
      yankPosition: null,
      markPosition: null,
      killRingMaxSize: 60,
      ...loadedData
    };
    console.log("Sonkil settings loaded:", this.settings);
  }
  async saveSettings() {
    await this.saveData(this.settings);
    console.log("Sonkil settings saved:", this.settings);
  }
};
var SonkilSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Sonkil Settings" });
    new import_obsidian.Setting(containerEl).setName("Kill Ring Size").setDesc("Maximum number of items to keep in kill ring").addText((text) => text.setValue(String(this.plugin.settings.killRingMaxSize)).setPlaceholder("60").onChange(async (value) => {
      const size = parseInt(value);
      if (!isNaN(size) && size > 0) {
        this.plugin.settings.killRingMaxSize = size;
        if (this.plugin.settings.killRing.length > size) {
          this.plugin.settings.killRing = this.plugin.settings.killRing.slice(-size);
          this.plugin.settings.killRingIndex = Math.min(
            this.plugin.settings.killRingIndex,
            this.plugin.settings.killRing.length - 1
          );
        }
        await this.plugin.saveSettings();
        console.log(`Kill Ring Size\uAC00 ${size}\uB85C \uBCC0\uACBD\uB418\uC5C8\uC2B5\uB2C8\uB2E4.`);
      }
    }));
  }
};
